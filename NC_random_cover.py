#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import itertools
import random

from openfermion.ops import MajoranaOperator
from openfermion.transforms import jordan_wigner, bravyi_kitaev

from FGU_random_cover import perm_parity, rand_alt_perm

#%% Functions for measurement counts

def rand_pauli_string(n):
    """
    Generates a random full-weight (n-qubit) Pauli string.
    """
    
    bases = ['X', 'Y', 'Z']
    
    P = []
    
    for i in range(n):
        P.append(random.sample(bases, 1)[0])
    
    return P

def permute_majorana_NC(indices, u):
    """
    Permutes a 2k-length set of Majorana indices with an n-length permutation
    u, consistent with the definition of Majorana operators and the fermionic
    swap unitary generated by u.

    Parameters
    ----------
    indices : iterable
        Input Majorana indices (subset of {0, ..., 2n-1}).
    u : iterable
        A permutation of {0, ..., n-1}.

    Returns
    -------
    tuple, int
        The permuted Majorana indices and the sign of the resulting operator
        (with respect to the canonical ascending-indices ordering).

    """
    
    assert len(indices) % 2 == 0
    assert len(indices) <= len(u)
    
    l = []
    for i in indices:
        if i % 2:
            l.append(int(2*u[(i - 1) // 2] + 1))
        else:
            l.append(int(2*u[i // 2]))
    
    sign = (-1)**perm_parity(l)
    l.sort()
    
    return tuple(l), sign

def tally_pauli_matches(ops_dict, map_dict, u, pauli_measurement):
    """
    Tallies which observables in obs_dict are measured by a given fermionic
    swap unitary (generated by u) + n-qubit Pauli measurement
    (pauli_measurement). Updates ops_dict in-place and returns a list of the
    observables which are measured by this circuit.
    
    For speed, this function requires a dictionary map_dict which is of the
    form {(majorana_indices) : (pauli_string)} as determined by a chosen
    fermion-to-qubit mapping. We do not verify that map_dict is compatible with
    ops_dict, nor that the mapping was implemented correctly. Pauli strings
    take the OpenFermion convention for QubitOperator.

    Parameters
    ----------
    ops_dict : dict
        Dictionary of observables we wish to measure. Formatted as
        {indices : number of times tallied}. Note that the indices must be
        sorted (ascending).
        The goal is to run this function many times until all tallies are at
        least r, where r is a user-determined hyperparameter.
    map_dict : dict
        Precomputed dictionary of fermion-to-qubit mappings for all Majorana
        indices in ops_dict. Pauli strings are expressed using OpenFermion
        convention.
    u : iterable
        A permutation of {0, ..., n-1}.
    pauli_measurement : list
        The full-weight Pauli basis to measure in.

    Returns
    -------
    measured_ops : list
        A list of the operators which are measured (diagonalized) by the
        measurement circuit. They are organized as a tuple, (Majorana, diagonal
        Pauli, sign), where
        
        V U(u) (Majorana) U(u)^\dagger V^\dagger = sign * (diagonal Pauli).
        
        V is the layer of single-qubit Clifford gates which rotates into the
        basis of pauli_measurement.

    """
    
    measured_ops = []
    
    for mu in ops_dict:
        
        permuted_mu, sign = permute_majorana_NC(mu, u)
        permuted_mu_pauli = map_dict[permuted_mu]
        
        if all(P[1] == pauli_measurement[P[0]] for P in permuted_mu_pauli):
            ops_dict[mu] += 1
            measured_ops.append((mu, permuted_mu_pauli, sign))
    
    return measured_ops

def majorana_to_pauli_dict(majorana_list, qubit_mapping='jw'):
    """
    Generates a dictionary from Majorana operator indices (ordered tuples) to
    its Pauli string representation under a given fermion-to-qubit mapping.
    Does not keep track of phases in front of the operators, since we always
    assume the convention
    
    Majorana operator = (-i)^k * \gamma_1 ... \gamma_{2k}.

    Parameters
    ----------
    majorana_list : iterable
        An iterable of Majorana tuples.
    qubit_mapping : str, optional
        The chosen fermion-to-qubit mapping, Jordan-Wigner ('jw') or Bravyi-
        Kitaev ('bk'). The default is 'jw'.

    Raises
    ------
    NotImplementedError
        If mappings other than Jordan-Wigner or Bravyi-Kitaev are specified.

    Returns
    -------
    majorana_to_pauli : dict
        Dictionary which maps between the Majorana and Pauli representations.

    """
    
    majorana_to_pauli = {}
    
    for majorana in majorana_list:
        
        if qubit_mapping == 'jw':
            op = jordan_wigner(MajoranaOperator(majorana))
        elif qubit_mapping == 'bk':
            op = bravyi_kitaev(MajoranaOperator(majorana))
        else:
            raise NotImplementedError(
                'Only jw and bk mappings currently supported.')
        
        majorana_to_pauli[majorana] = next(iter(op.terms))
    
    return majorana_to_pauli

def construct_random_measurements_NC(ops_dict, map_dict, n, r=10):
    """
    Constructs a random cover of ops_dict using the hyperparameter r. That is,
    it generates random (n-permutations + Pauli measurements) until all
    Majorana operators in ops_dict have been accounted for at least r times.

    Parameters
    ----------
    ops_dict : dict
        Dictionary of Majorana operators which we wish to measure. {key : val}
        pattern should be {(majorana_indices) : number_of_times_accounted_for}.
    map_dict : dict
        Precomputed dictionary of fermion-to-qubit mappings for all Majorana
        indices in ops_dict. Pauli strings are expressed using OpenFermion
        convention.
    n : int
        Number of qubits (currently only supports fermion-to-qubit encodings
        wwhich map n orbitals to n qubits).
    r : int, optional
        The minimum number of times each operator must be covered until the
        function halts. The default is 10.

    Returns
    -------
    random_measurements : dict
        The resulting cover of Majorana operators. The dictionary pattern is
        {(permutation, pauli_measurement) : [(measured_op_indices, sign)]}.

    """
    random_measurements = {}
    
    while any(counts < r for counts in ops_dict.values()):
        u = rand_alt_perm(n)
        pauli_measurement = rand_pauli_string(n)
        if (u, tuple(pauli_measurement)) in random_measurements:
            continue
        
        measured_ops = tally_pauli_matches(ops_dict, map_dict, u,
                                           pauli_measurement)
        
        if len(measured_ops) > 0:
            random_measurements[(u, tuple(pauli_measurement))] = measured_ops
    
    return random_measurements

#%% Example usage

if __name__ == '__main__':
    
    """Set system size and order of k-RDM desired (usually k = 2 is sufficient,
    e.g., for local electron-electron interactions)."""
    n_orbitals = 6
    k = 2

    """Construct a k-RDM in the Majorana representation as a dictionary of form
    {majorana_indices : expectation_value}. Here, we insert all possible Majorana
    operators if we are interested in the entire k-RDM; however, the dictionary
    can be constructed differently if only a subset of observables are desired."""
    majorana_k_rdm_counts = {}
    for j in range(1, k + 1):
        for mu in itertools.combinations(range(2 * n_orbitals), 2 * j):
            majorana_k_rdm_counts[mu] = 0

    """Since this approach depends on the fermion-to-qubit mapping, we must specify
    one. Here we are using the Jordan-Wigner encoding. Specifically, jw_mapping
    is a dictionary that associates each Majorana operator of interest to its Pauli
    operators. We precompute and store this in memory in order to avoid wasting time
    by constantly recomputing the same mapping over and over."""
    jw_mapping = majorana_to_pauli_dict(majorana_k_rdm_counts.keys(),
                                        qubit_mapping='jw')

    """Generate a random cover of FGU measurement settings such that all Majorana
    operators are covered at least r = 50 times. This means that if one wishes to
    estimate each operator to statistical accuracy corresponding to S samples, each
    measurement setting (circuit) needs to be repeated only S/r times."""
    rand_meas = construct_random_measurements_NC(majorana_k_rdm_counts, jw_mapping,
                                                 n_orbitals, r=50)
